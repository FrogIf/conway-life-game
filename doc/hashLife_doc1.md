译自: [An Algorithm for Compressing Space and Time](https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478)

技术支持: 通义千问

# 一种压缩空间和时间的算法

--- ***让一个慢程序变得快速可能会带来既喜悦又沮丧的体验。但有时一种新方法会带来惊人的改进***

让一个慢程序变得快速可能会带来喜悦与挫败感交织的体验。通常情况下，你能做到的最好方法是使用低级技巧将程序速度提升一倍或四倍；例如，许多读者可能已经通过位级操作实现了约翰·康威（John Conway）的“生命游戏”（Game of Life），从而获得了显著的速度提升。然而，有时一种全新的方法，结合几个简单的想法，却能带来惊人的改进。“HashLife”是一种简单的算法，由威廉·高斯珀（William Gosper）发明（“Exploiting Regularities in Large Cellular Spaces,” Physica 10D, 1984），它结合了四叉树（quadtrees）和记忆化（memoization），为“生命游戏”带来了天文数字级别的加速。在本文中，我将从最简单的“生命游戏”实现逐步演化出这一算法，解释其工作原理，并运行一些宇宙模拟，观察它们在数万亿代进化过程中增长到数十亿个细胞的演变过程。

马丁·加德纳（Martin Gardner）从1970年10月起在《科学美国人》杂志上发表的关于康威生命游戏（Conway's Game of Life）的专栏文章，激励了整整一代程序员；一个令人惊叹的二维生命世界可以从几个简单的规则中诞生，这些规则易于编程和显示。生命游戏（图1）是在无限的二维网格上进行的单人游戏。网格中的每个单元格要么是活的（1，用黑点表示），要么是死的。每个拥有两个或三个活着的邻居（八个紧邻的单元格）的活细胞将继续存活，否则它将死亡。任何被恰好三个活细胞包围的死细胞将被视为新生细胞，并进入下一代。所有规则同时应用于所有单元格。这些规则导致了稳定或振荡的生命形式——滑翔机和宇宙飞船可以在宇宙中自我移动，生命形式可以无限制地生长或完全消亡。初始只有九个活细胞的种子模式可以经历数以千计的代际突变，不断移动的混沌活动区域会喷发出滑翔机，周围则是大量的稳定结构。

<image src="img/1.png" width="400px" >

> 图1：一些生命游戏的例子。左侧是一个稳定的“面包”模式。左上角展示了闪烁器的两个阶段，这是一种周期为2的振荡器。从左下角到右上角的对角线上，显示了滑翔机在穿越宇宙时经历的四个阶段

生命游戏（Game of Life）的最简单实现使用一对二维数组来表示宇宙有限区域的状态。在每一代中，通过计算旧数组中某个细胞的邻居数量，来确定该细胞在新数组中的状态，然后交换数组并更新屏幕。这种方法存在一些令人沮丧的问题：宇宙越大，程序运行越慢；然而，较小的宇宙会限制模式的增长，人为地约束它们。对基础算法的第一个改进是用无限的宇宙替换有限的宇宙；在任何给定时间，它虽然是有限的，但可以根据需要增加其大小。我使用了一种简单的树形表示法，称为“四叉树”（quadtree，图2）。

<image src="img/2.png" width="400px" >

> 图2：一个包含“面包”（Loaf）模式的4×4单元格的四叉树表示法

树的每个节点代表宇宙的一部分正方形区域。树的叶子节点是单个比特，要么是 1（活细胞），要么是 0（死细胞）。每个非叶子节点代表一个更大的正方形，由四个子节点组成，这些子节点根据它们相对于中心的方向命名：`nw` 表示西北方向的小正方形，`ne` 表示东北方向的小正方形，依此类推。节点的层级是指到叶子节点的距离；叶子节点位于第 0 层。因此，第 n 层的节点代表一个每边长度为 \(2^n\) 的正方形区域。

实现生命游戏算法的直接方法是编写一个递归函数，该函数接收一个特定层级的树，并要么就地更新树，要么返回一棵全新的树。我选择返回一棵全新的树。如果我能返回与原树相同层级的新树，算法将会非常简单。然而，这在没有额外信息的情况下是不可能的，因为当前节点的邻居节点也会影响边界细胞下一代的计算结果。

解决这一问题的一种方法是将同一层级的邻居节点作为参数传递给函数；另一种方法是维护邻居节点的指针。而我选择了更简单的方法：递归函数的结果是一个比原节点低一层且相对于原节点居中的节点。例如，函数接收一个第 2 层的节点，该节点表示宇宙中一个 4×4 的正方形区域，并返回一个第 1 层的节点，该节点表示从中可以直接计算得出的 2×2 正方形区域。同样地，函数接收一个第 5 层的节点，该节点表示宇宙中一个 32×32 的正方形区域，并返回一个第 4 层的节点，该节点表示中心部分已进化一代的 16×16 像素区域。这种设计使你可以在不可变数据结构上采用完全函数式的方法，假设你喜欢这样的方式。

大多数在树上工作的递归算法只是简单地对子节点进行递归调用，然后以某种方式组合结果。如果在这里使用类似*代码清单1*的代码进行操作，计算出的正方形之间将会出现间隙，如图3所示。因此，需要一种更复杂的方法。我不能直接在递归调用中使用现有的子节点；相反，我必须创建临时的子节点，并将它们适当移位，以确保得到的结果正方形与我们的要求对齐。

代码清单1:

```java
class Node {
   Node nextGeneration() {
      if (level == 2) {
         ... do base case through normal simulation ...
      } else {
         return new Node(nw.nextGeneration(), ne.nextGeneration(),
                       sw.nextGeneration(), se.nextGeneration()) ;
      }
   }
}
```

<image src="img/3.png" width="150px" >

> 图3: 为什么一个简单的递归算法无法工作: 黑色外正方形表示一个节点的区域；四个红色内正方形是子节点。我想计算下一代中蓝色内正方形的区域，但子节点的内部正方形是绿色正方形，它们无法组合成蓝色内正方形，因为它们与蓝色正方形没有重叠。

我构建了九个新的节点，这些节点向下两层，并且进行了适当的移位。为了构建这些向下两层的节点，我实际上访问了向下三层的节点来组成新的节点。从这九个新节点中，我创建了四个向下一层的新节点。正是这四个新节点成为了我递归操作的对象。这使我得到了位于适当位置的结果节点，因此我可以将它们组合成处于正确层级所需的输出节点（参见图4）。

<image src="img/4.png" width="150px" >

> 图4: 解决间隙问题的一种方法：从现有节点的组成部分构建新的子节点，以计算我们实际需要的正方形。同样，蓝色是我希望计算的区域；我将其拆分为四个绿色节点。通过使用从原始节点的子节点构造出的九个红色子节点的各种组合来构建子节点，从而计算出这四个蓝色节点。

在*代码清单2*中，我确实对实用性做出了一些小的妥协。对于任何我知道完全为空的树，我通过共享节点来构建；参见图4。当我计算任何节点的下一代时，我首先检查它是否为空，如果为空，则立即返回一个空的子树。

代码清单2:

```java
Node centeredSubnode() {
   return new Node(nw.se, ne.sw, sw.ne, se.nw) ;
}
Node centeredHorizontal(Node w, Node e) {
   return new Node(w.ne.se, e.nw.sw, w.se.ne, e.sw.nw) 
;
}
Node centeredVertical(Node n, Node s) {
   return new Node(n.sw.se, n.se.sw, s.nw.ne, s.ne.nw);
}
Node centeredSubSubnode() {
   return new Node(nw.se.se, ne.sw.sw, sw.ne.ne, 
se.nw.nw) ;
}
Node nextGeneration() {
   if (level == 2) {
      ... do base case through normal simulation ...
   } else {
      Node n00 = nw.centeredSubnode(),
           n01 = centeredHorizontal(nw, ne),
           n02 = ne.centeredSubnode(),
           n10 = centeredVertical(nw, sw),
           n11 = centeredSubSubnode(),
           n12 = centeredVertical(ne, se),
           n20 = sw.centeredSubnode(),
           n21 = centeredHorizontal(sw, se),
           n22 = se.centeredSubnode() ;
      return new Node(
         new Node(n00, n01, n10, n11).nextGeneration(),
         new Node(n01, n02, n11, n12).nextGeneration(),
         new Node(n10, n11, n20, n21).nextGeneration(),
         new Node(n11, n12, n21, n22).nextGeneration());
   }
}
```

到目前为止，我的算法并没有任何改进。它消耗更多的内存，运行速度更慢。它生成了许多需要被管理或垃圾回收的新节点。它的递归过程也相对复杂。我将通过两个步骤解决所有这些问题——节点的规范形式化（canonicalization）和“记忆化”（memoization）。

四叉树数据结构（参见图5）相比简单的位图占用显著更多的空间（尽管仅以一个固定的比例增加）；对于表示一个256×256宇宙的树，0叶子节点和1叶子节点的数量之和为65,536，同时存在16,384 + 4,096 + 1,024 + 256 + 64 + 16 + 4 + 1 = 21,845个非叶子节点。每个节点代表一个固定的、不可变的位图，因此没有必要为具有相同值的节点创建不同的实例。所有的1叶子节点可以用一个规范的1叶子节点来表示；同样地，所有西北象限为1叶子节点且其他三个象限为0叶子节点的节点，可以用一个规范的此类节点实例来表示。这种规范化的处理一直延伸到树的根节点。对节点进行规范化需要一个简单的哈希集合，并使用通常针对树结构的递归方法；一旦节点被规范化，节点的值就完全由指向该节点的指针表示（包括在比较时），因此节点的哈希函数可以简单地混合四个子节点的地址。这个规范化步骤类似于Java中的`String.intern()`函数所做的事情，并体现了不可变结构的一个优势。

<image src="img/5.png" width="400px" >

> 图5: 另一种结构

此外，当需要时（假设哈希集合存储的是指针），提供规范化的哈希集合可以方便的进行垃圾回收，即使是在像 C++ 这样的语言中也是如此。只需创建一个新的空哈希集合，将其与当前的规范化哈希集合交换，从当前根节点重新规范化，然后删除旧哈希集合中有但新哈希集合中没有的所有节点。

规范化通过 `CanonicalTreeNode` 类实现，在该类中，我提供了哈希所需的基础设施，并重写了负责创建每个节点实例的工厂方法。

在解决了空间问题之后，我对 `nextGeneration` 函数做了一个简单的改动来解决时间问题：我将该函数“记忆化”（也就是说，我保存已计算的结果以便之后重复使用，而不是重新计算）。记忆化不过是将函数的结果缓存起来，以防它被用相同的参数再次调用时可以复用。考虑经典的记忆化例子——斐波那契函数。其通常的递归定义如示例 1(a) 所示。这个函数的增长速度与所需的调用次数一样，都是指数级的。但是通过添加一个简单的数组作为缓存，如示例 1(b) 所示，可以让它在 \(n\) 的线性时间内运行。尽管有更高效的方法来计算斐波那契数，但这种技术本身具有广泛的实用性。

```
(a)

int fib(int n) {
   if (n < 3)
      return 1 ;
   return fib(n-1) + fib(n-2) ;
}
(b)

int cache[] ;
int fib(int n) {
   if (n < 3)
      return 1 ;
   if (cache[n])
      return cache[n] ;
   return cache[n] = fib(n-1) + fib(n-2) ;
}
```

> 示例1: 递归定义

为了对 `nextGeneration` 进行记忆化，我在节点数据结构中添加了一个单一指针，用于存储该节点上调用 `nextGeneration` 函数的结果；如果这个指针不为空，则它包含结果节点。通过保持 `nextGeneration` 纯函数特性所启用的记忆化所带来的加速，完全抵消了因返回比参数低一层的节点而引入的效率损失。实现这一扩展的类是 `MemoizedTreeNode`。

此时，生命游戏算法还尚未完全成为 HashLife。在一些具有规律性模式的大型宇宙中，它的速度已经比传统的算法更快，即使是一些高度优化的算法也不例外。例如，在经典的繁殖者模式（参考图4）中，尽管种群数量随着代数的平方增长，每一代所需的时间却是恒定的。到目前为止，我们构建的所有基础设施为你迈向最终的 HashLife 算法提供了最后一个巨大的步骤 -- 时间压缩。

之前我提到过，我会运行一些非平凡的模式数万亿代。即使只是数到一万亿，对于现代 CPU 来说也需要相当长的时间；然而，HashLife 能够在不到一秒钟的时间内将繁殖者模式运行到一万亿代，并输出其最终种群数量 1,302,083,334,180,208,337,404。这只需要对截至目前所描述的程序进行相对较小的改动。（你可以希望在此处停止阅读，尝试自己思考这个改动是什么。）

最后的调整是改变递归调用计算的代数。目前，它在每一层只计算一代。这种方法虽然可以加速计算，但运行时间至少会与代数呈线性关系，即使是在空宇宙中也是如此。相反，我们重写 `nextGeneration` 函数，使其计算的代数随着层级增加而增加。也就是说，在第二层（4×4 节点）时，它仍然只向前计算一代；在第三层（8×8 节点）时，它计算两代；在第八层（256×256 节点）时，它则向前计算 64 代。

事实证明，这一改动在某种程度上简化了递归函数，因为下一代的计算会处理掉之前需要许多额外函数来完成的部分节点移位操作。*代码清单3*展示了代码的变化结果。完整的实现位于 `HashLifeTreeNode` 类中（参见附带的 zip 文件）。提供的代码始终根据根节点的当前层级来执行步骤；可以通过在高于某一固定值的层级使用我们为 `TreeNode` 提供的原始 `nextGeneration` 函数，而在低于该层级时使用新的函数来对其进行修改。如果希望增大步长，只需调用 `expandUniverse` 方法即可轻松提升根节点的层级。

代码清单3:

```java
Node horizontalForward(Node w, Node e) {
   return node(w.ne, e.nw, w.se, e.sw).nextGeneration();
}
Node verticalForward(Node n, Node s) {
   return node(n.sw, n.se, s.nw, s.ne).nextGeneration();
}
Node centeredForward() {
   return node(nw.se, ne.sw, sw.ne, se.nw).nextGeneration() ;
}
Node nextGeneration() {
   if (level == 2) {
      ... do base case through normal simulation ...
   } else {
      Node n00 = nw.nextGeneration(),
           n01 = horizontalForward(nw, ne),
           n02 = ne.nextGeneration(),
           n10 = verticalForward(nw, sw),
           n11 = centeredForward(),
           n12 = verticalForward(ne, se),
           n20 = sw.nextGeneration(),
           n21 = horizontalForward(sw, se),
           n22 = se.nextGeneration() ;
      return new Node(
         new Node(n00, n01, n10, n11).nextGeneration(),
         new Node(n01, n02, n11, n12).nextGeneration(),
         new Node(n10, n11, n20, n21).nextGeneration(),
         new Node(n11, n12, n21,  n22).nextGeneration());
   }
}
```

这就是 HashLife。正如所展示的，这段代码在大多数常见模式上能够获得惊人的加速效果；对于大多数模式，在初始的预热阶段（由于大量的哈希操作，这段时间内它的运行速度比传统算法慢），之后它会开始“加速”，在单位时间内计算的代数呈指数级增长。

让我回到故事的起点。2000年12月，在一个私人邮件列表中，Nick Gotts 发布了一个全新的、令人惊叹的52细胞模式，名为“metacatacryst”。他相信这个模式展示了二次增长的特性，但并不完全确定。他询问是否有人可以用 HashLife 对其进行模拟。当时，我刚刚完成了一个快速的传统生命游戏程序，并且已经看到了一些关于这种程序可能如何工作的提示和传闻，而由于 Bill Gosper 的原始实现仅能在少数 Lisp 机器上运行，我认为是时候尝试编写一个自己的版本了。通过初步融入我至今所介绍的这些想法，我得以将 metacatacryst 模拟运行到数万亿代，并证明它在整个范围内都表现出二次增长的特性。这个模式极其美丽，具有只有在运行数十亿代并以某种足够缩放、可缩放的形式展示结果时才能欣赏到的分形特性。

我还使用 HashLife 发现了另一个“长寿模式”（Methuselah），这是一种初始规模小但持续时间很长的生命形态，其初始种群仅有12个细胞，却能延续超过12,000代才稳定下来。其他人则正在利用 HashLife 研究大型构造模式，这些模式可以模拟图灵机、寄存器机以及具有前所未见速度的宇宙飞船。

真正的喜悦在于算法，而这个算法完全归功于比尔·高斯珀（Bill Gosper），我将所有的赞誉和荣誉都献给他。对于那些想要进行实验的人，开源程序 Golly 可在 [http://sf.net/projects/golly/](http://sf.net/projects/golly/) 获取。

HashLife 是一种独特的算法，它将生命游戏的下一代函数的记忆化技术应用于宇宙的四叉树表示。同样的技术也可以应用于其他领域。